BEGIN;

-- Drop i rätt ordning pga FK
DROP TABLE IF EXISTS allocation CASCADE;
DROP TABLE IF EXISTS planned_activity CASCADE;
DROP TABLE IF EXISTS course_instance CASCADE;
DROP TABLE IF EXISTS course_layout CASCADE;
DROP TABLE IF EXISTS teaching_activity CASCADE;
DROP TABLE IF EXISTS employee CASCADE;
DROP TABLE IF EXISTS department CASCADE;
DROP TABLE IF EXISTS job_title CASCADE;
DROP TABLE IF EXISTS person CASCADE;

-- PERSON
CREATE TABLE person (
  person_id        INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  personal_number  VARCHAR(20)  NOT NULL UNIQUE,
  first_name       VARCHAR(100) NOT NULL,
  last_name        VARCHAR(100) NOT NULL,
  phone_number     VARCHAR(20)  NOT NULL,
  address          VARCHAR(200) NOT NULL
);

-- JOB TITLE
CREATE TABLE job_title (
  job_title_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  job_title    VARCHAR(100) NOT NULL UNIQUE
);

-- DEPARTMENT (manager_id FK läggs efter employee pga cykel)
CREATE TABLE department (
  department_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  department_name VARCHAR(100) NOT NULL UNIQUE,
  manager_id      INT NULL
);

-- EMPLOYEE
CREATE TABLE employee (
  employment_id  INT PRIMARY KEY, -- ofta given av HR/system; inte auto här
  skill_set      VARCHAR(200) NOT NULL,
  salary         NUMERIC(12,2) NOT NULL CHECK (salary >= 0),
  supervisor_id  INT NULL,
  person_id      INT NOT NULL UNIQUE,
  department_id  INT NOT NULL,
  job_title_id   INT NOT NULL,

  CONSTRAINT fk_employee_person
    FOREIGN KEY (person_id) REFERENCES person(person_id),

  CONSTRAINT fk_employee_department
    FOREIGN KEY (department_id) REFERENCES department(department_id),

  CONSTRAINT fk_employee_job_title
    FOREIGN KEY (job_title_id) REFERENCES job_title(job_title_id),

  CONSTRAINT fk_employee_supervisor
    FOREIGN KEY (supervisor_id) REFERENCES employee(employment_id)
);

-- Nu kan department.manager_id FK kopplas
ALTER TABLE department
  ADD CONSTRAINT fk_department_manager
  FOREIGN KEY (manager_id) REFERENCES employee(employment_id);

-- COURSE LAYOUT
CREATE TABLE course_layout (
  course_layout_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  course_code      VARCHAR(10)  NOT NULL UNIQUE,
  course_name      VARCHAR(200) NOT NULL,
  min_students     INT NOT NULL CHECK (min_students >= 0),
  max_students     INT NOT NULL CHECK (max_students >= min_students),
  hp               NUMERIC(3,1) NOT NULL CHECK (hp > 0)
);

-- COURSE INSTANCE
CREATE TABLE course_instance (
  course_instance_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  num_students       INT NOT NULL CHECK (num_students >= 0),
  study_period       CHAR(2) NOT NULL CHECK (study_period IN ('P1','P2','P3','P4')),
  study_year         INT NOT NULL CHECK (study_year BETWEEN 1900 AND 2100),
  course_layout_id   INT NOT NULL,

  CONSTRAINT fk_ci_layout
    FOREIGN KEY (course_layout_id) REFERENCES course_layout(course_layout_id),

  -- normalt 1 instance per kurs+period+år
  CONSTRAINT uq_ci_layout_period_year
    UNIQUE (course_layout_id, study_year, study_period)
);

-- TEACHING ACTIVITY
CREATE TABLE teaching_activity (
  teaching_activity_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  activity_name        VARCHAR(50) NOT NULL UNIQUE,
  factor               NUMERIC(4,2) NOT NULL CHECK (factor > 0)
);

-- PLANNED ACTIVITY (planerade timmar per kursinstans + aktivitet)
CREATE TABLE planned_activity (
  course_instance_id     INT NOT NULL,
  teaching_activity_id   INT NOT NULL,
  planned_hours          NUMERIC(10,2) NOT NULL CHECK (planned_hours >= 0),

  PRIMARY KEY (course_instance_id, teaching_activity_id),

  CONSTRAINT fk_pa_ci
    FOREIGN KEY (course_instance_id) REFERENCES course_instance(course_instance_id),

  CONSTRAINT fk_pa_ta
    FOREIGN KEY (teaching_activity_id) REFERENCES teaching_activity(teaching_activity_id)
);

-- ALLOCATION (faktiska tilldelade timmar per lärare + kursinstans + aktivitet)
CREATE TABLE allocation (
  employment_id         INT NOT NULL,
  course_instance_id    INT NOT NULL,
  teaching_activity_id  INT NOT NULL,
  allocated_hours       NUMERIC(10,2) NOT NULL CHECK (allocated_hours >= 0),

  PRIMARY KEY (employment_id, course_instance_id, teaching_activity_id),

  CONSTRAINT fk_al_emp
    FOREIGN KEY (employment_id) REFERENCES employee(employment_id),

  CONSTRAINT fk_al_ci
    FOREIGN KEY (course_instance_id) REFERENCES course_instance(course_instance_id),

  CONSTRAINT fk_al_ta
    FOREIGN KEY (teaching_activity_id) REFERENCES teaching_activity(teaching_activity_id)
);

-- Indexar som hjälper 5.2 queries
CREATE INDEX idx_ci_year_period ON course_instance(study_year, study_period);
CREATE INDEX idx_pa_ci ON planned_activity(course_instance_id);
CREATE INDEX idx_al_ci ON allocation(course_instance_id);
CREATE INDEX idx_al_emp ON allocation(employment_id);

-- Constraint: max 4 olika course_instances per period+år per employee
CREATE OR REPLACE FUNCTION enforce_max_4_courses_per_period()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_period CHAR(2);
  v_year   INT;
  v_count  INT;
BEGIN
  SELECT study_period, study_year
    INTO v_period, v_year
  FROM course_instance
  WHERE course_instance_id = NEW.course_instance_id;

  SELECT COUNT(DISTINCT a.course_instance_id)
    INTO v_count
  FROM allocation a
  JOIN course_instance ci ON ci.course_instance_id = a.course_instance_id
  WHERE a.employment_id = NEW.employment_id
    AND ci.study_year = v_year
    AND ci.study_period = v_period;

  IF v_count > 4 THEN
    RAISE EXCEPTION
      'Employee % is allocated to % course instances in % % (max 4)',
      NEW.employment_id, v_count, v_year, v_period;
  END IF;

  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_max_4_courses
AFTER INSERT OR UPDATE OF employment_id, course_instance_id
ON allocation
FOR EACH ROW
EXECUTE FUNCTION enforce_max_4_courses_per_period();

COMMIT;
